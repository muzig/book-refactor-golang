# 重构原则

小生把该章节主要的内容梳理输出来，便于后期梳理记忆。后面括号（）里面的内容，为个人观点。

## 目录

- [何谓重构](#何谓重构)
- [为何重构](#为何重构)
- [何时重构](#何时重构)
- [重构的价值](#重构的价值)
- [怎么和经理交流](#怎么和经理交流)
- [重构的难题](#重构的难题)
- [何时不该重构](#何时不该重构)
- [重构性能](#重构性能)
- [重构的起源](#重构的起源)

## 何谓重构

重构：

- 名词版：（一改变，一不变，二优化）改变软件的内部结果；软件可观察行为的不变；优化理解成本以及修改成本
- 动词版：（强调结构变化的过程）重构代码结构的行为

## 为何重构

总结原因：（三个易）

- 易理解 - 降低代码的理解负担（个人觉得，这个不好说；有的时候重度使用设计模式，会致使一些经验少的程序员较难去理解程序的内容，看编程环境很重要）
- 易debug
- 易编程 - 提高开发编码效率

## 何时重构

三次法则：

1. 第一次开发，只管去做
2. 第二次开发，可以勉强做，就不重构
3. 第三次开发，很难做的话，就重构

实际重构场景：

- **添加功能**的时候遇阻 - 对于功能的数据流不清晰，很难去理解的时候
- **debug**的时候遇阻 - 很难发现bug，但的确存在问题
- **复审代码**的时候 - 发现代码设计的不合理；比如《极限编程》中描述的“结对编程”

tips：

1. 复审代码常用的方式
    - UML示意图展示设计
    - CRC卡展示软件情节
    - 数据流图

## 重构的价值

程序的两面性：

- 今天能做什么 - （直接价值：需要立竿见影效果的时候）
- 明天能做什么 - （长期价值：需要放长线钓大鱼的时候）

## 怎么和经理交流

情景一：

若经理懂一点技术，那么直接表明即可

情景二：

若经理只对质量感兴趣，从质量的角度去产生程序重构的价值

情景三：

其实很多经理表面是“质量驱动”，更多是“进度驱动”；有争议的方式就是不告诉经理

### 间接层和重构

间接层是一把双刃剑；尽量减少间接层，因为会多管理对象；但同时偶尔又需要间接层拆机复杂。

好处：

- 允许逻辑共享
- 分开解释意图和实现
- 隔离变化
- 封装条件逻辑

## 重构的难题

### 数据库相关

重构会导致数据模型的改变，从而无法匹配旧的数据模型，这就需要数据迁移。

途径：

1. 兼容旧的数据模型，只是在旧的数据模型上面，进行一层封装
2. 迁移数据
    1. 手动迁移
    2. 工具迁移

### 修改接口

目的：保留旧接口的使用，让其调用新接口，千万不要复制函数实现，会陷入泥潭

方式：

- 使用内置提供的**deprecation** || **deprecated** 关键字进行使用者提醒

tips：

- 不要过早的发布接口，请修改你的代码所有权政策，使重构更顺畅

## 何时不该重构

- 代码根本无法运作，很难理解其意思，直接重写
- 项目的期限问题，时间短紧迫的情况下

## 重构性能

编写快速软件的方法：

- 时间预算法
- 持续关注法
- 提升法

## 重构的起源

略