# 重构原则

小生把该章节主要的内容梳理输出来，便于后期梳理记忆。后面括号（）里面的内容，为个人观点。

## 目录

- [何谓重构](#何谓重构)
- [为何重构](#为何重构)
- [何时重构](#何时重构)
- [重构的价值](#重构的价值)
- [](#)
- [](#)
- [](#)

## 何谓重构

重构：

- 名词版：（一改变，一不变，二优化）改变软件的内部结果；软件可观察行为的不变；优化理解成本以及修改成本
- 动词版：（强调结构变化的过程）重构代码结构的行为

## 为何重构

总结原因：（三个易）

- 易理解 - 降低代码的理解负担（个人觉得，这个不好说；有的时候重度使用设计模式，会致使一些经验少的程序员较难去理解程序的内容，看编程环境很重要）
- 易debug
- 易编程 - 提高开发编码效率

## 何时重构

三次法则：

1. 第一次开发，只管去做
2. 第二次开发，可以勉强做，就不重构
3. 第三次开发，很难做的话，就重构

实际重构场景：

- **添加功能**的时候遇阻 - 对于功能的数据流不清晰，很难去理解的时候
- **debug**的时候遇阻 - 很难发现bug，但的确存在问题
- **复审代码**的时候 - 发现代码设计的不合理；比如《极限编程》中描述的“结对编程”

tips：

1. 复审代码常用的方式
    - UML示意图展示设计
    - CRC卡展示软件情节
    - 数据流图

## 重构的价值

程序的两面性：

- 今天能做什么 - （直接价值：需要立竿见影效果的时候）
- 明天能做什么 - （长期价值：需要放长线钓大鱼的时候）